# 探索文档：主智能体设计

## 探索目标

设计 Vibe Drive 的主智能体（Master Agent），用于演示系统的完整能力。

## 背景

### 当前状态

现有 `VibeAgent` 是一个氛围编排智能体，具备以下工具：
- `MusicTool` - 音乐搜索与播放
- `MusicSeedTool` - 音乐灵感种子
- `LightTool` - 氛围灯控制
- `ScentTool` - 香氛控制
- `MassageTool` - 按摩椅控制
- `NarrativeTool` - 叙事生成

### 定位

**主智能体是演示用途**：
- 拥有 Vibe Drive 所有工具
- 不连接真实车机硬件
- 用于展示系统能力和交互体验

---

## 待探索话题

- [x] 话题1：主智能体与氛围智能体的关系
- [x] 话题2：主智能体的能力边界
- [x] 话题3：对话交互设计
- [x] 话题4：演示场景设计

---

## 探索记录

### 话题1：主智能体与氛围智能体的关系

**讨论日期**：2025-12-26

#### 1.1 架构选择

**选定方案：B - 多 Agent 协作**

```
┌─────────────────────────────────────┐
│         主智能体 (Master Agent)      │
│  - 对话理解                          │
│  - 意图识别                          │
│  - 任务分发                          │
└──────────────┬──────────────────────┘
               │ 调用
               ▼
┌─────────────────────────────────────┐
│         氛围智能体 (Vibe Agent)      │
│  - 氛围编排                          │
│  - 工具调用                          │
│  - 环境感知                          │
└─────────────────────────────────────┘
```

#### 1.2 职责划分

| 智能体 | 职责 | 工具 |
|--------|------|------|
| 主智能体 | 对话、意图理解、直接控制 | 全部工具 + 管理工具 |
| 氛围智能体 | 自动氛围编排 | Music, Light, Scent, Massage, Narrative |

**主智能体工具清单**：

```
主智能体工具：
├── 继承氛围智能体工具（可直接干预）
│   ├── MusicTool (搜索/播放)
│   ├── MusicSeedTool
│   ├── LightTool
│   ├── ScentTool
│   ├── MassageTool
│   └── NarrativeTool
│
└── 额外管理工具
    ├── callVibeAgent (调用氛围智能体自动编排)
    ├── getEnvironment (获取环境数据)
    └── setEnvironment (模拟环境)
```

**设计理由**：用户可能对自动编排结果不满意，主智能体可直接修改，无需重新走氛围智能体。

#### 1.2.1 say 工具（语音输出控制）

**问题**：ReAct 架构下，AI 输出很多中间内容，如果都转语音会很吵。

**解决方案**：只有调用 `say` 工具时才转语音。

```
AI 输出：
├── 思考过程 → 只显示文字，不转语音
├── 工具调用 → 只显示文字，不转语音
└── say("你好") → 转语音播放
```

**say 工具**：
```java
@Tool("对用户说话，会转为语音播放")
public String say(String text) {
    return text; // 前端收到后调用 TTS
}
```

#### 1.3 主智能体的双重身份

**选定方案：C - 始终融合**

主智能体同时具备两种能力，自然融合：

| 层面 | 能力 | 示例 |
|------|------|------|
| 角色层 | 车机智能体 | "播放轻音乐"、"调暗灯光" |
| 元认知层 | 项目自知 | "你能做什么"、"这个怎么实现的" |

**特点**：
- 知道自己是虚拟演示环境
- 了解 Vibe Drive 项目的功能和架构
- 不需要显式切换模式

#### 1.4 异步调用与消息队列

**调用方式**：异步调用 + 用户优先消息队列

```
┌───────────────────────────────────────────────┐
│                 主智能体                        │
│                                               │
│  ┌─────────────┐      ┌─────────────────┐    │
│  │ 用户消息队列  │─────▶│                 │    │
│  │ (高优先级)   │      │    处理中心      │    │
│  └─────────────┘      │                 │    │
│                       │ 用户优先        │    │
│  ┌─────────────┐      │ 可中断氛围处理   │    │
│  │ 氛围消息队列  │─────▶│                 │    │
│  │ (低优先级)   │      └─────────────────┘    │
│  └─────────────┘                              │
└───────────────────────────────────────────────┘
```

**处理规则**：

| 场景 | 行为 |
|------|------|
| 正在处理用户消息 | 氛围结果入队等待 |
| 正在处理氛围结果 + 用户消息进来 | 中断，氛围结果存回队列，优先处理用户 |
| 空闲 | 按优先级取队列消息处理 |

**中断策略**：B - 暂存继续
- 氛围智能体返回一次性完整结果
- 中断时直接存回队列
- 用户处理完后继续处理

#### 1.5 语音交互方案

**简化决策**：放弃监听型，采用对讲机模式

```
用户按住按钮 → 说话 → 松开 → Whisper 转文本 → 发给主智能体
```

**语音转文本**：本地 Whisper（Docker 部署）
- 镜像：`onerahmet/openai-whisper-asr-webservice:latest-gpu`
- 端口：9000
- 模型：medium 或 large-v3
- 硬件：4060 Laptop（8GB 显存）

---

### 话题2：主智能体的能力边界

**讨论日期**：2025-12-26

#### 2.1 能力范围

| 能力 | 可以 | 不可以 |
|------|------|--------|
| 氛围控制 | ✅ 调用工具 | |
| 闲聊 | ✅ 聊天 | |
| 技术架构 | ✅ 解释项目 | |
| 文本操作 | | ❌ 写文档/代码 |
| 文件操作 | | ❌ 读写文件 |
| 外部请求 | | ❌ 联网/API |

**原则**：只能"说"和"控制工具"，不能"写"。

---

### 话题3：对话交互设计

**讨论日期**：2025-12-26

#### 3.1 ReAct 过程中用户打断

**问题**：ReAct 模式执行时间长，用户可能在中间说话。

**解决方案**：Spring AOP 拦截工具调用

```java
@Aspect
@Component
public class ToolInterceptor {

    @Autowired
    private MessageQueue messageQueue;

    @Around("@annotation(dev.langchain4j.agent.tool.Tool)")
    public Object checkBeforeToolExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        // 每次工具调用前检查
        if (messageQueue.hasUserMessage()) {
            throw new UserInterruptException("用户有新消息");
        }
        return joinPoint.proceed();
    }
}
```

**处理逻辑**：
- 每次工具调用前检查消息队列
- 有新消息 → 抛出中断异常
- 上层捕获异常，处理新消息

---

### 话题4：演示场景设计

**讨论日期**：2025-12-26

#### 4.1 演示场景

| 场景 | 用户说 | 主智能体行为 |
|------|--------|-------------|
| 编排环境 | "模拟夜间高速" | 调用 setEnvironment |
| 编排氛围 | "帮我放松一下" | 调用 callVibeAgent |
| 直接控制 | "灯光调暗" | 调用 LightTool |
| 项目介绍 | "这个项目怎么实现的" | 调用 getProjectIntro |

#### 4.2 项目介绍文档

**方案**：在 resources 放置简单文档

```
resources/
└── docs/
    └── project-intro.md  ← README 内容
```

**工具**：
```java
@Tool("获取项目介绍文档")
public String getProjectIntro() {
    return resourceLoader.load("docs/project-intro.md");
}
```

---

## 参考资源

- 现有代码：`VibeAgentFactory.java`
- 系统提示词：`vibe-system.txt`
