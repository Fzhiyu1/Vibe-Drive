# 探索文档：音乐播放器与播放 API

## 探索目标

研究如何在 Vibe Drive 项目中实现音乐播放功能，包括：
- 前端音乐播放器实现
- Web Audio API 频谱分析
- 后端音乐 API 设计
- Three.js 频谱可视化集成

## 背景

当前 Vibe Drive 项目的车机屏幕（useCarScreen.ts）已实现基础的音乐播放器 UI：
- 显示歌曲名（歌手 - 标题）
- 进度条 + 时间显示
- 播放/暂停图标

但目前只是**静态展示**，没有实际的音频播放功能。需要探索如何实现真正的音乐播放。

## 待探索内容

- [x] 前端播放技术选型
- [x] 音乐来源选型
- [x] AI 调用音乐的 Tool 设计
- [x] 播放模式设计（经典/探索）
- [x] 音乐与氛围联动
- [x] Go 微服务集成方案
- [x] MusicTool 改造设计
- [ ] 车机屏幕频谱柱实现（可选）
- [ ] 网易云登录功能（可选，支持 VIP 歌曲）

---

## 探索记录

### 话题1：技术选型

**讨论日期**：2025-12-25

**问题**：前端音乐播放应该用什么技术？

**方案对比**：

| 方案 | 优点 | 缺点 |
|------|------|------|
| HTML5 Audio | 简单、兼容性好 | 无法获取频谱数据 |
| **Web Audio API** | 可获取频谱、可处理音频 | 稍复杂 |
| Howler.js | 封装好、跨浏览器 | 额外依赖 |

**结论**：采用 **分层架构**

- **基础层**：HTML5 Audio（播放/暂停/进度）
- **升级层**：Web Audio API（可选，用于频谱可视化）

**理由**：
- 频谱可视化是可选功能，不是必须
- HTML5 Audio 足够满足基础播放需求
- 需要频谱时再引入 Web Audio API

---

### 话题2：音乐来源选型

**讨论日期**：2025-12-25

**问题**：音乐从哪里来？

**方案对比**：

| 方案 | 优点 | 缺点 |
|------|------|------|
| 后端静态资源 | 稳定、无版权问题 | 曲库有限 |
| 对象存储 | 可扩展 | 需要自己上传 |
| ~~Binaryify/NeteaseCloudMusicApi~~ | ~~曲库丰富~~ | ❌ 已停止维护（2024.4 版权问题）|
| **go-musicfox/netease-music** | Go 包、可用 | 需要 Go 环境 |
| Spotify | 官方支持 | 国内需翻墙、需 Premium |

**结论**：采用 **go-musicfox/netease-music** Go 包

**项目地址**：https://github.com/go-musicfox/go-musicfox

**集成方式**：
1. 写一个 Go 微服务封装 API
2. 或将加密逻辑移植到 Java/TypeScript

**实验验证**：✅ 已验证可用（见实验1）

---

### 话题2.1：集成方案选型

**讨论日期**：2025-12-25

**问题**：如何将 go-musicfox/netease-music 集成到 Vibe Drive？

**方案对比**：

| 方案 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **Go 微服务** | 独立 Go HTTP 服务 | 直接用现有包 | 多一个服务 |
| 移植到 Java | 翻译加密逻辑 | 单一后端 | 工作量大 |
| 移植到 TS | 前端直接调用 | 减少后端 | 安全性差 |

**结论**：采用 **Go 微服务** 方案

**项目结构**（Monorepo）：
```
Vibe-Drive/
├── vibe-drive-frontend/   # Vue 前端
├── vibe-drive-backend/    # Java 后端
└── services/
    └── music-api/         # Go 微服务（新增）
```

**执行指南**：见 `docs/guides/music-api-setup.md`

---

### 话题3：Web Audio API 基础

**问题**：如何使用 Web Audio API 播放音乐并获取频谱？

**核心概念**：

```
AudioContext
    │
    ├── Source（音频源）
    │   ├── AudioBufferSourceNode（预加载）
    │   └── MediaElementSourceNode（流式）
    │
    ├── AnalyserNode（频谱分析）
    │
    └── Destination（输出设备）
```

**基础代码**：

```typescript
// 创建音频上下文
const audioContext = new AudioContext()

// 从 <audio> 元素创建源
const audio = new Audio('/music/song.mp3')
const source = audioContext.createMediaElementSource(audio)

// 创建分析器
const analyser = audioContext.createAnalyser()
analyser.fftSize = 256  // FFT 大小，影响频谱精度

// 连接节点
source.connect(analyser)
analyser.connect(audioContext.destination)

// 获取频谱数据
const dataArray = new Uint8Array(analyser.frequencyBinCount)
analyser.getByteFrequencyData(dataArray)  // 0-255 的频率数据
```

**关键参数**：

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| fftSize | FFT 窗口大小 | 256（性能）/ 512（精度）|
| smoothingTimeConstant | 平滑系数 | 0.8（平滑）/ 0.5（灵敏）|
| frequencyBinCount | 频率柱数量 | fftSize / 2 |

---

### 话题3：前端播放器架构

**问题**：如何设计前端音乐播放器的架构？

**方案**：Vue Composable 封装

```
composables/
├── useAudioPlayer.ts      # 音频播放控制
├── useAudioAnalyser.ts    # 频谱分析
└── three/
    └── useCarScreen.ts    # 已有，需扩展
```

**useAudioPlayer.ts 接口设计**：

```typescript
interface UseAudioPlayerReturn {
  // 状态
  isPlaying: Ref<boolean>
  currentTime: Ref<number>
  duration: Ref<number>
  volume: Ref<number>
  currentSong: Ref<Song | null>

  // 方法
  play: () => Promise<void>
  pause: () => void
  seek: (time: number) => void
  setVolume: (volume: number) => void
  loadSong: (song: Song) => Promise<void>

  // 频谱
  getFrequencyData: () => Uint8Array
}
```

**useAudioAnalyser.ts 接口设计**：

```typescript
interface UseAudioAnalyserReturn {
  // 频谱数据
  frequencyData: Ref<Uint8Array>

  // 分析结果
  bass: Ref<number>      // 低频能量 0-1
  mid: Ref<number>       // 中频能量 0-1
  treble: Ref<number>    // 高频能量 0-1

  // 方法
  connect: (source: AudioNode) => void
  tick: () => void
}
```

---

### 话题4：AI 调用音乐的 Tool 设计

**讨论日期**：2025-12-25

**问题**：AI 怎么知道要播放什么歌？如何处理各种异常情况？

#### 4.1 Tool 拆分设计

**原方案**（单一 Tool）：
```java
playMusic(mood, scene) → 直接播放
```
问题：AI 无法在播放前筛选结果。

**改进方案**（拆分为两个 Tool）：
```java
searchMusic(query) → 返回候选列表
playMusicById(id) → 播放指定歌曲
```

**ReAct 流程示例**：
```
AI: 调用 searchMusic("River Flows in You")
观察: [
  { id: 1, title: "River Flows in You", artist: "Yiruma", plays: 500万 },
  { id: 2, title: "River Flows in You", artist: "某翻唱", plays: 2000 },
]
AI: 第一个是原唱且播放量高，选这个
AI: 调用 playMusicById(1)
```

#### 4.2 异常情况处理

| 情况 | 解决方案 |
|------|----------|
| 搜到翻唱版 | AI 在观察阶段根据歌手名判断 |
| 歌曲无版权 | searchMusic 返回 `available: false` |
| AI 幻觉（歌不存在） | searchMusic 返回空列表，AI 换策略 |
| 模糊搜索返回不相关结果 | AI 根据标题相似度、播放量判断 |

#### 4.3 searchMusic 返回字段

```json
{
  "id": "123",
  "title": "歌曲名",
  "artist": "歌手",
  "plays": 5000000,
  "available": true,
  "duration": 240
}
```

**AI 选择依据**：
- `plays` 播放量 → 质量参考
- `title` 歌名 → 是否匹配搜索意图
- `artist` 歌手 → 是否是原唱/知名歌手
- `available` → 是否可播放

#### 4.4 当前实现分析

**现状**：
- MusicTool 只有一个 `recommendMusic()` 方法
- 数据来源是本地 Mock JSON 文件
- AI 无法搜索、无法选择

**问题**：
```
当前: recommendMusic() → 直接返回5首歌（AI 没有选择机会）
```

**LangChain4j 支持多轮 Tool Calling**，流程不是死的：
```
AI 思考 → 调用 Tool A → 观察结果 → 调用 Tool B → 观察结果 → 回复
```

**改造方案**：
```
searchMusic(keyword) → 返回20首候选
AI 观察 → 根据播放量、歌手等选择
playMusic(id) → 播放指定歌曲
```

这样 AI 才能真正实现 **ReAct 模式**（思考 → 行动 → 观察 → 思考）

---

### 话题5：播放模式设计

**讨论日期**：2025-12-25

**问题**：AI 应该推荐"确定性高"的歌，还是"探索性"的歌？

**结论**：支持两种模式

| 模式 | 说明 | 搜索策略 |
|------|------|----------|
| **经典模式** | 播放知名歌曲 | AI 推荐具体歌名 → 搜索 |
| **探索模式** | 发现新音乐 | 风格+心情关键词 → AI 从结果中选 |

**经典模式流程**：
```
用户: "来点轻松的音乐"
AI: 推荐《Canon in D》
AI: 调用 searchMusic("Canon in D Pachelbel")
AI: 从结果中选择原版
AI: 调用 playMusicById(xxx)
```

**探索模式流程**：
```
用户: "来点轻松的音乐"
AI: 调用 searchMusic("轻松 钢琴 纯音乐")
观察: [多首歌曲，包含小众作者]
AI: 根据播放量、歌名选择一首
AI: 调用 playMusicById(xxx)
```

**关键点**：即使探索模式，也由 AI 选择，不是随机。

---

### 话题6：后端音乐 API 设计

**问题**：后端需要提供哪些音乐相关的 API？

**API 设计**：

#### 4.1 获取音乐列表

```
GET /api/music/list
Query: ?mood=relaxed&limit=10

Response:
{
  "songs": [
    {
      "id": "song-001",
      "title": "Peaceful Mind",
      "artist": "Ambient Artist",
      "duration": 240,
      "url": "/music/peaceful-mind.mp3",
      "coverUrl": "/covers/peaceful-mind.jpg",
      "mood": ["relaxed", "calm"],
      "bpm": 80
    }
  ]
}
```

#### 4.2 获取推荐音乐（基于氛围）

```
GET /api/music/recommend
Query: ?environment=night_highway&mood=relaxed

Response:
{
  "recommended": {
    "id": "song-002",
    "title": "Night Drive",
    "reason": "适合夜间高速驾驶的放松音乐"
  }
}
```

#### 4.3 MusicTool（Agent 调用）

```java
@Tool("根据当前氛围推荐并播放音乐")
public MusicSetting playMusic(
    @P("心情: relaxed/energetic/focused") String mood,
    @P("场景: highway/city/parking") String scene
) {
    // AI 根据环境选择合适的音乐
}
```

**MusicSetting 数据模型**：

```java
public record MusicSetting(
    Song song,           // 当前播放歌曲
    boolean isPlaying,   // 播放状态
    int volume,          // 音量 0-100
    PlayMode mode        // SINGLE/LOOP/SHUFFLE
) {}

public record Song(
    String id,
    String title,
    String artist,
    int duration,        // 秒
    String url,
    String coverUrl,
    List<String> mood,
    int bpm
) {}
```

---

### 话题5：Three.js 频谱可视化

**问题**：如何在车机屏幕上显示音乐频谱？

**方案**：扩展 useCarScreen.ts

**可视化样式**：

| 样式 | 描述 | 难度 |
|------|------|------|
| 柱状图 | 经典频谱柱 | ⭐ |
| 波形图 | 连续曲线 | ⭐⭐ |
| 圆形频谱 | 环形展开 | ⭐⭐⭐ |

**柱状图实现**：

```typescript
function drawSpectrum(ctx: CanvasRenderingContext2D, data: Uint8Array) {
  const barCount = 32  // 显示32根柱子
  const barWidth = 10
  const gap = 2
  const startX = 20
  const baseY = 140

  ctx.fillStyle = '#00aaff'

  for (let i = 0; i < barCount; i++) {
    // 从频谱数据中采样
    const index = Math.floor(i * data.length / barCount)
    const value = data[index]
    const height = (value / 255) * 50  // 最大高度50px

    ctx.fillRect(
      startX + i * (barWidth + gap),
      baseY - height,
      barWidth,
      height
    )
  }
}
```

**与 useCarScreen 集成**：

```typescript
export function useCarScreen(meshes: CarInteriorMeshes): UseCarScreenReturn {
  // ... 现有代码

  let spectrumData: Uint8Array | null = null

  function updateSpectrum(data: Uint8Array) {
    spectrumData = data
    drawPlayer()  // 重绘包含频谱
  }

  function drawPlayer() {
    // ... 现有绘制代码

    // 绘制频谱
    if (spectrumData && currentSong) {
      drawSpectrum(ctx, spectrumData)
    }
  }

  return {
    updateSong,
    updateProgress,
    updateSpectrum,  // 新增
    tick
  }
}
```

---

### 话题6：音乐与氛围联动

**问题**：音乐如何与车内氛围联动？

**联动维度**：

| 音乐属性 | 氛围效果 |
|----------|----------|
| BPM（节奏） | ~~氛围灯流光速度~~ |
| 低频能量 | ~~氛围灯亮度脉冲~~ |
| 心情标签 | ~~推荐灯光颜色~~ |
| 高潮段落 | ~~灯光特效触发~~ |

**最终结论**：❌ 不联动

**理由**：灯光由 AI 控制，不应该让歌曲绕过 AI 直接控制灯光。

**替代方案**：✅ 车机屏幕上显示音乐柱（频谱可视化）

---

### 话题7：音乐柱（频谱可视化）

**讨论日期**：2025-12-25

**问题**：如何在车机屏幕上显示音乐频谱？

**位置**：车机屏幕播放器 UI 下方

**布局设计**：
```
┌─────────────────────────┐
│ ▶ 歌手 - 歌名           │
│ ████████░░░░ 2:30/4:00  │
│  █  ██                  │
│  █ █ █ █  █   █         │
│ █ █ █ █ █ █ █ █         │
└─────────────────────────┘
```

**技术方案**：

```
Audio 播放
    ↓
AnalyserNode 分析
    ↓
频谱数据 (Uint8Array)
    ↓
useCarScreen.updateSpectrum()
    ↓
Canvas 绘制
```

**实现文件**：
- `useAudioPlayer.ts` - 音频播放 + AnalyserNode
- `useCarScreen.ts` - 绘制频谱柱

---

**Agent 联动**：

```
用户: "来点适合夜间驾驶的音乐"

Agent 思考:
1. 当前环境: 夜间高速
2. 推荐音乐: 节奏舒缓的电子音乐
3. 联动氛围: 深蓝色灯光 + 慢速流光

Agent 调用:
- MusicTool.playMusic(mood="relaxed", scene="highway")
- LightTool.setLight(color="#1E90FF", speed=1.0)
```

---

## 实验记录

### 实验1：网易云 API 可用性验证 ✅

**日期**：2025-12-25

**目标**：验证 `go-musicfox/netease-music` Go 包是否可用

**文件**：`experiments/netease-api/`

**测试结果**：

| 功能 | 结果 |
|------|------|
| 搜索 API | ✅ 正常（返回 260 首歌曲）|
| 获取播放 URL | ✅ 正常 |
| VIP 歌曲 | ⚠️ 部分可用 |

**结论**：**可用！** 详见 `experiments/netease-api/README.md`

---

### 实验2：Web Audio API 基础（待做）

**目标**：验证频谱获取和可视化

**文件**：`experiments/audio-player/01-basic-spectrum.html`

**验收标准**：
- [ ] 播放本地音频文件
- [ ] 实时显示频谱柱状图
- [ ] 播放/暂停控制

### 实验3：Three.js 集成（待做）

**目标**：在 CanvasTexture 上显示频谱

**文件**：`experiments/audio-player/02-threejs-spectrum.html`

**验收标准**：
- [ ] 车机屏幕显示频谱
- [ ] 频谱与音乐同步
- [ ] 不影响现有播放器 UI

---

## 参考资源

- [Web Audio API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
- [AnalyserNode - MDN](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode)
- [Three.js CanvasTexture](https://threejs.org/docs/#api/en/textures/CanvasTexture)
